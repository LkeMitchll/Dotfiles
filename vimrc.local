" ===============================
" VIMRC LOCAL - LUKE MITCHELL
" ===============================

if has('gui_running')
  so ~/.gvimrc
endif

" ===============================
" General Settings
" ===============================
set noeb vb t_vb=
set shell=/usr/local/bin/zsh " Set shell
let mapleader = ',' " Override leader
set hlsearch " Highlight searched term
set nocompatible   " Disable vi-compatibility
set laststatus=2   " Always show the statusline
set clipboard=unnamed " use system clipboard
set ignorecase " Case-insensitive tab completion
set autochdir " Automatically change dirs for ':e'
set listchars=eol:¬,extends:…,precedes:…

" ===============================
" Language & Encoding
" ===============================
setglobal langmenu=en_GB.UTF-8
setglobal encoding=utf8
setglobal fileencoding=utf-8

" ==============================
" Tabs
" ==============================
set smartindent
set softtabstop=2
set expandtab
set autoindent

" ==============================
" Theme
" ==============================
set background=dark
colorscheme gruvbox

" | Cursor |
:hi CursorLine   cterm=NONE ctermbg=black ctermfg=NONE guibg=black guifg=NONE
:hi CursorColumn cterm=NONE ctermbg=black ctermfg=NONE guibg=black guifg=NONE

" | Line No's |
:hi LineNr ctermbg=NONE ctermfg=12
:hi CursorLineNr ctermbg=NONE ctermfg=5
:hi ColorColumn ctermbg=236

" | Splits |
:hi VertSplit ctermbg=NONE ctermfg=4

" | Gutter |
:hi clear SignColumn
:hi SignColumn guibg=NONE ctermbg=NONE
:hi SyntasticWarningSign ctermbg=NONE ctermfg=11
:hi SyntasticErrorSign ctermbg=NONE ctermfg=9
:hi GitGutterAdd ctermbg=NONE
:hi GitGutterChange ctermbg=NONE
:hi GitGutterDelete ctermbg=NONE
:hi GitGutterChangeDelete ctermbg=NONE

" | Tabs |
:hi TabLineFill ctermbg=236 ctermfg=NONE
:hi TabLine ctermbg=236 ctermfg=8 cterm=bold
:hi TabLineSel ctermbg=2 ctermfg=0

" | CTRLp Dialog |
:hi Pmenu guibg=black ctermbg=7 ctermfg=black
:hi PmenuSel ctermbg=9 ctermfg=white

" | Basic |
:hi Comment ctermfg=8 cterm=italic
:hi Nontext ctermfg=239

" ===============================
" Syntax
" ===============================
au BufRead,BufNewFile *.zsh-theme,*.zsh set filetype=zsh
au BufRead,BufNewFile *.xm set filetype=logos
au BufRead,BufNewFile *.vimrc,*.vimrc.*,*.vim set filetype=vim
let g:jsx_ext_required = 0 " Allow JSX in normal JS files

" ===============================
" Plugins
" ===============================

" | Airline |
let g:airline_theme='gruvbox'

let g:airline_left_sep = ''
let g:airline_right_sep = ''
let g:airline#extensions#obsession#indicator_text = '✓'

let g:airline#extensions#hunks#enabled=0
let g:airline#extensions#bufferline#enabled=0
let g:airline#extensions#tagbar#enabled=0
let g:airline#extensions#csv#enabled=0
let g:airline#extensions#virtualenv#enabled = 0
let g:airline#extensions#wordcount#enabled = 0
let g:airline#extensions#whitespace#enabled = 0

let g:airline_section_b = ''
let g:airline_section_y = ''
let g:airline_section_z = "%{airline#extensions#obsession#get_status()}%{line('.')}/%{line('$')}"

" | Indentline |
let g:indentLine_color_term = 4
let g:indentLine_char = "¦"

" | NeoSnippet | "
let g:neosnippet#snippets_directory='~/.vim/snippets'

" | NeoComplete |"
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0

" Use neocomplete.
let g:neocomplete#enable_at_startup = 1

" Use smartcase.
let g:neocomplete#enable_smart_case = 1

" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
  \ 'default' : '',
  \ 'vimshell' : $HOME.'/.vimshell_hist',
  \ 'scheme' : $HOME.'/.gosh_completions'
    \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
  let g:neocomplete#keyword_patterns = {}
endif

let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplete#close_popup() . "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplete#close_popup()
inoremap <expr><C-e>  neocomplete#cancel_popup()

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif

" Plugin key-mappings.
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)
" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
\ "\<Plug>(neosnippet_expand_or_jump)"
\: "\<TAB>"

" | EasyMotion  |
hi EasyMotionTarget ctermbg=none ctermfg=1
hi EasyMotionShade ctermbg=none ctermfg=4
hi EasyMotionTarget2Second ctermbg=none ctermfg=1
hi EasyMotionTarget2First ctermbg=none ctermfg=1

" | CTRLP |
" Search from current directory instead of project root
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_custom_ignore = {
  \ 'dir':  '\v[\/]\.(git|hg|svn|sass-cache)$',
  \ 'file': '\v\.(exe|so|dll)$',
  \ }
" Ignore bundler and sass cache
set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*
" Disable output and VCS files
set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem

" | Fugitive (Git) |
nnoremap <silent> <leader>gs :Gstatus<CR>
nnoremap <silent> <leader>gd :Gdiff<CR>
nnoremap <silent> <leader>gc :Gcommit<CR>
nnoremap <silent> <leader>gb :Gblame<CR>
nnoremap <silent> <leader>gl :Glog<CR>
nnoremap <silent> <leader>gp :Git push<CR>
nnoremap <silent> <leader>gr :Gread<CR>
nnoremap <silent> <leader>gw :Gwrite<CR>
nnoremap <silent> <leader>ge :Gedit<CR>

" | The Silver Searcher |
if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor\ --column
  set grepformat=%f:%l:%c%m
  let g:EasyGrepCommand=1

  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  unlet g:ctrlp_user_command
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
endif

" | Syntastic |
"let g:syntastic_debug = 1
let g:syntastic_check_on_wq = 1
let g:syntastic_aggregate_errors = 1
let g:syntastic_css_checkers = ['stylelint']
let g:syntastic_scss_checkers = ['scss_lint', 'sass']
let g:syntastic_scss_scss_lint_args="--config ~/.scss-lint.yml"
let g:syntastic_python_checker= "flake8"
let g:syntastic_python_checker_args="--ignore=E501,W601"
let g:syntastic_haml_checkers = ['haml_lint', 'haml']
let g:syntastic_ruby_checkers = ['rubocop']
let g:syntastic_html_tidy_exec = "/usr/local/bin/tidy"
let g:syntastic_coffee_coffelint_args = "--csv --file ~/.coffeelint.json"

" | Vimux |
map <Leader>tr :VimuxPromptCommand<CR>
map <Leader>tc :VimuxCloseRunner<CR>
map <Leader>ti :VimuxInspectRunner<CR>
map <Leader>tl :VimuxRunLastCommand<CR>
map <Leader>tt :RunFocusedCuke<CR>

" | Emmet |
let g:user_emmet_mode='a'

" | Rails |
let g:rails_projections = { 'app/decorators/*.rb': { 'command': 'decorator' }}

" | Obsession/Prosession |
let g:prosession_on_startup = 1

" | Ctags |
set tags=./tags

" ===============================
" Keyboard Shortcuts
" ===============================

" | Reload This file |
map <Leader>rv :so ~/.vimrc.local<CR>

" | bind K to grep word under cursor |
nnoremap K :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>

" | Session Saving keys |
map <F2> :call SaveSess()<CR>
map <F3> :call RestoreSess()<CR>

"  | NumberToggle |
let g:NumberToggleTrigger="<F10>"

" | Remove trailing whitespace [f5] |
nnoremap <silent> <F5> :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar>:nohl<CR>

"  | UPPERCASE and lowercase conversion |
nnoremap g^ gUiW
nnoremap gv guiW

" | Error navigation |
nnoremap ]l :lnext<CR>
nnoremap [l :lprev<CR>

" ===============================
" Functions
" ===============================

" | Cheatsheet |
let g:cheatsheet_dir = "~/.vim/"
let g:cheatsheet_ext = "~/.vim/cheatsheet.txt"

command! -nargs=? -complete=customlist,CheatSheetComplete CS call ToggleCheatSheet(<f-args>)
nmap <F6> :CS<CR>

" strip extension from complete list
function! CheatSheetComplete(A)
  return map(split(globpath(g:cheatsheet_dir, a:A.'*'.g:cheatsheet_ext)),
    \ "v:val[".strlen(expand(g:cheatsheet_dir)).
    \ ":-".(strlen(g:cheatsheet_ext) + 1)."]")
endfun

" specify cheatsheet or use filetype of open buffer as default
" instead of saving window status in a boolean variable,
" test if the file is open (by name). If a boolean is used,
" you'll run into trouble if you close the window manually with :wq etc
function! ToggleCheatSheet(...)
  let s:file = g:cheatsheet_ext
  if bufwinnr(s:file) != -1
    call ToggleWindowClose(s:file)
  else
    call ToggleWindowOpen(s:file)
  endif
endfun

" stateless open and close so it can be used with other plugins
function! ToggleWindowOpen(file)
  let splitr = &splitright
  set splitright
  exe ":vsp ".a:file
  exe ":vertical resize 84"
  if !splitr
    set splitright
  endif
endfun

function! ToggleWindowClose(file)
  let w_orig = bufwinnr('%')
  let w = bufwinnr(a:file)
  exe w.'wincmd w'
  exe ':silent wq!'
  if w != w_orig
    exe w_orig.'wincmd w'
  endif
endfun
" END CHEATSHEET

" Auto Sessions
fu! SaveSess()
  execute 'mksession! /Users/luke/.vim/session.vim'
endfunction

fu! RestoreSess()
execute 'so /Users/luke/.vim/session.vim'
if bufexists(1)
  for l in range(1, bufnr('$'))
    if bufwinnr(l) == -1
      exec 'sbuffer ' . l
    endif
  endfor
endif
endfunction

autocmd VimLeave * call SaveSess()
